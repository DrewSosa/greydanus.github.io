I"ΩQ<div>
	<style>
		#linkbutton:link, #linkbutton:visited {
		  background-color: rgb(180,180,180);
		  border-radius: 4px;
		  color: white;
		  padding: 6px 0px;
		  width: 150px;
		  text-align: center;
		  text-decoration: none;
		  display: inline-block;
		  text-transform: uppercase;
		  font-size: 13px;
		  margin: 8px;
		}

		#linkbutton:hover, #linkbutton:active {
		  background-color: rgba(160,160,160);
		}

		.playbutton {
		  background-color: rgb(148, 196, 146);
		  border-width: 0;
		  /*background-color: rgba(255, 130, 0);*/
		  border-radius: 4px;
		  color: white;
		  padding: 5px 8px;
		  /*width: 60px;*/
		  text-align: center;
		  text-decoration: none;
		  text-transform: uppercase;
		  font-size: 12px;
		  /*display: block;*/
		  /*margin-left: auto;*/
		  margin: 8px 0px;
		  margin-right: auto;
		  min-width:60px;
		}

		.playbutton:hover, .playbutton:active {
		  background-color: rgb(128, 176, 126);
		}
	</style>
</div>

<div class="imgcap" style="display: block; margin-left: auto; margin-right: auto; width:99.9%">
  <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;padding-right:10px;">
    <video id="video_sim" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_simulator.mp4" type="video/mp4" />
    </video>
    <button class="playbutton" id="video_sim_button" onclick="playPauseSim()">Play</button> 
    <div style="text-align: left;margin-left:10px;margin-right:10px;">Using model-based planning to play pool/billiards. The goal is to impart the tan cue ball with an initial velocity so as to move the blue ball to the black target.</div>
  </div>
  <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;padding-right:10px;">
    <video id="video_base" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_base.mp4" type="video/mp4" />
    </video>
    <button class="playbutton" id="video_base_button" onclick="playPauseBase()">Play</button> 
    <div style="text-align:left;margin-left:10px;margin-right:10px;">A baseline RNN trained on billiards dynamics can also be used for model-based planning. It's inefficient because it has to "tick" at a constant rate.</div>
  </div>
   <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;">
    <video id="video_jumpy" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_jumpy.mp4" type="video/mp4" />
    </video>
    <button class="playbutton" id="video_jumpy_button" onclick="playPauseJumpy()">Play</button> 
    <div style="text-align:left;margin-left:10px;margin-right:10px;">By contrast, a Jumpy RNN trained on the same task can perform planning in many fewer steps by jumping over spans of time where motion is predictable.</div>
  </div>
</div>

<script> 
function playPauseSim() { 
  var video = document.getElementById("video_sim"); 
  var button = document.getElementById("video_sim_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 

function playPauseBase() { 
  var video = document.getElementById("video_base"); 
  var button = document.getElementById("video_base_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 

function playPauseJumpy() { 
  var video = document.getElementById("video_jumpy"); 
  var button = document.getElementById("video_jumpy_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 
</script>

<div style="display: block; margin-left: auto; margin-right: auto; width:100%; text-align:center;">
	<a href="https://openreview.net/pdf?id=4c3WeBTErrE" id="linkbutton" target="_blank">Read the paper</a>
	<a href="" id="linkbutton" target="_blank">Run in browser</a>
	<a href="https://github.com/greydanus" id="linkbutton" target="_blank">Get the code</a>
</div>

<h2 id="change-it-is-said-happens-slowly-and-then-all-at-once">Change, it is said, happens slowly and then all at once‚Ä¶</h2>

<!-- Change, it is said, happens slowly and then all at once. -->
<p>Billiards balls move across a table before colliding and changing trajectories; water molecules cool slowly and then undergo a rapid phase transition into ice; and economic systems enjoy periods of stability interspersed with abrupt market downturns. That is to say, many time series exhibit periods of relatively homogeneous change divided by important events. Despite this, recurrent neural networks (RNNs) ‚Äì a popular type of time series model ‚Äì treat time in uniform intervals. In doing so, they are forced to spend much of their time stepping through periods of relatively predictable change.</p>

<p>In this blog post, I propose an extension of RNNs that avoids this waste of time. The extension is called a ‚ÄúJumpy RNN‚Äù because it can jump over long time intervals or linger on short ones. It can predict twenty seconds into the future, or one second into the future, depending on the context.</p>

<p>Jumpy RNNs are similar to regular RNNs in most ways. Like RNNs, they maintain a hidden state \(h\) which summarizes their knowledge about the world at a given point in time. And like RNNs, they can perform the same set of cell updates on this hidden state (eg. vanilla, LSTM, or GRU updates). But one way in which they differ from regular RNNs is that they maintain a hidden velocity vector in addition to a hidden state vector. They assume that \(h\) changes in a locally-linear fashion and thus they are able to predict dynamics by multiplying \(\dot h\) by change in time and adding it to the state: \(h(t) = h + \dot h \Delta t\). In other words, in addition to predicting hidden states, Jumpy RNNs also predict <em>the locally-linear dynamics of those states</em>. I like to think of Jumpy RNNs as sequence models over functions rather than states. And so by predicting one function that can summarize several adjacent states, Jumpy RNNs gain the ability to jump over long spans of homogeneous change.</p>

<div class="imgcap_noborder" style="display: block; margin-left: auto; margin-right: auto; width:100%; min-width: 300px">
  <img src="/assets/jumpy-rnn/hero.png" style="width:100%" />
</div>

<p>In order to compare our model to regular RNNs, we used both of them to model a series of simple physics problems including the collisions of two billiards balls. We found that our jumpy model was able to learn these patterns at least as well as the baseline while using a fraction of the forward simulation steps. This makes it a great candidate for model-based planning because it can predict the outcome of taking an action much more quickly than a baseline model. And since the hidden-state dynamics are piecewise-linear over time, we can solve for the hidden state at arbitrary points along a trajectory. This allows us to simulate the dynamics of billiards, for example, at a higher temporal resolution than the original training data:</p>

<div class="imgcap" style="display: block; margin-left: auto; margin-right: auto; width:99.9%">
    <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;padding-right:10px;">
    <video id="video_sim2" style="width:100%;min-width:250px;">
      <source src="/assets/jumpy-rnn/video_simulator.mp4" type="video/mp4" />
    </video>
    <button class="playbutton" id="video_sim2_button" onclick="playPauseSim2()">Play</button> 
    <div style="text-align: left;margin-left:10px;margin-right:10px;">This video will give you a sense for the underlying temporal resolution of the billiards dataset on which we trained the Jumpy RNN.</div>
  </div>
  <div style="width:32%; min-width:250px; display: inline-block; vertical-align: top;text-align:center;">
    <video id="video_interp" style="width:100%;min-width:250px;">
    	<source src="/assets/jumpy-rnn/video_interp.mp4" type="video/mp4" />
    </video>
    <button class="playbutton" id="video_interp_button" onclick="playPauseInterp()">Play</button> 
    <div style="text-align:left;margin-left:10px;">This video shows how we can use a Jumpy RNN to obtain dynamics estimates at a higher temporal resolution than that of the original simulator. 
<!--     We can do this because the latent dynamics of the model are continuous and piecewise-linear in time. -->
  </div>
  </div>
</div>

<script> 
function playPauseSim2() { 
  var video = document.getElementById("video_sim2"); 
  var button = document.getElementById("video_sim2_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 

function playPauseJumpy2() { 
  var video = document.getElementById("video_jumpy2"); 
  var button = document.getElementById("video_jumpy2_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 

function playPauseInterp() { 
  var video = document.getElementById("video_interp"); 
  var button = document.getElementById("video_interp_button");
  if (video.paused) {
    video.play();
	button.textContent = "Pause";}
  else {
    video.pause(); 
	button.textContent = "Play";}
} 
</script>

<p>I am going to give more specific examples of how Jumpy RNNs improve over regular RNNs later. But first, we need to talk about what regular RNNs are good at and why they are worth improving upon in the first place.</p>

<h2 id="the-value-of-rnns">The Value of RNNs</h2>

<p>Recurrent neural networks are interesting because they can learn complex, long-range structure in time series data simply by predicting one point at a time. For example, if you train them on sequences of words, you can use them to translate from one language to another, or to generate possible completions to a prompt. And if you train them on observations of a robot arm, you can use them to generate realistic paths that the arm might take in the future.</p>

<p>One of the things that makes these models so flexible is that they use a hidden vector \(h\) to store memories of past observations. And they can <em>learn</em> to read, write, and erase information from \(h\) in order to make accurate predictions about the future. RNNs are Turing-complete and, unlike other models that are Turing-complete (eg. HMMs or FSMs) they can learn and operate on noisy, high-dimensional data. Here is an incomplete list of things people have trained RNNs to do:</p>

<ul>
  <li>‚Ä¢\(~~\)Translate text from one language to another (think Google Translate)</li>
  <li>‚Ä¢\(~~\)Control a robot hand in order to solve a Rubik‚Äôs Cube</li>
  <li>‚Ä¢\(~~\)Defeat professional human gamers in StarCraft</li>
  <li>‚Ä¢\(~~\)Caption images</li>
  <li>‚Ä¢\(~~\)Generate realistic handwriting</li>
  <li>‚Ä¢\(~~\)Convert text to speech</li>
  <li>‚Ä¢\(~~\)Convert speech to text</li>
  <li>‚Ä¢\(~~\)Compose simple songs</li>
  <li>‚Ä¢\(~~\)‚Ä¶and much more</li>
</ul>

<h2 id="the-limitations-of-rnns">The Limitations of RNNs</h2>

<p><strong>Uniform ticks.</strong> I‚Äôve been interested in RNNs for a long time, but one aspect of their design has always bothered me: they can only tick at one uniform rate, sort of like a clock. At each tick they make one observation of the world, perform one read-erase-write on their memory, and send one output message. This seems too rigid. We wouldn‚Äôt open our eyes, close them, think, then act, and repeat. This would be silly because sometimes we need to think fast and other times we need to think slow. For us, time is a very dynamic thing.</p>

<p>One of the great things about being able to think in this manner is that it helps us plan. For example, we can jump to three months in the future when we will be traveling to another country, realize that we‚Äôll need our passport updated, and then make a short-term plan for how to do that. Our short-term plan might be: stop at the Post Office to get passport photos after work. And in order to pay for those photos, grab some extra cash from the piggy bank. And so the simple act of putting a $20 bill in our wallets can have many layers of planning behind it. What‚Äôs more is that planning is happening across many time scales. Our brain does this by jumping from one event to another without thinking much about the intervening duration, and this is something that models like RNNs aren‚Äôt great at doing.</p>

<p><strong>Discrete time steps.</strong> Another issue with RNNs is that they perceive time as a series of discrete ‚Äútime steps‚Äù that connect neighboring states. Since time is actually a continuous variable ‚Äì it has a definite value even in between RNN ticks ‚Äì we really should use models that treat it as such. In other words, when we ask our model what the world looked like at time \( t=1.42\) seconds, it should not have to locate the two ticks that are nearest in time and then interpolate between them, as is the case with RNNs. Rather, it should be able to give a well-defined answer. Models like Neural ODEs (which are closely related to this work) take a step in this direction, but it‚Äôs still an underexplored area of research.</p>

<h2 id="our-results">Our Results</h2>

<p>Our work on Jumpy RNNs was an attempt to fix these issues. Our model can jump over different durations of time and this allows it to tick more often when a lot is happening and less often otherwise. As we explained in the introduction, Jumpy RNNs are different from regular RNNs in that they predict a hidden state velocity in addition to a hidden state. Taken together, these two quantities represent a linear dynamics function in the RNN‚Äôs latent space. A second modification we make is to have the model predict the duration of time \(\Delta t\) over which that dynamics function is valid. In some cases, when change is happening at a constant rate, this value can be quite large. For example, when we create a toy dataset of perfectly linear motion, our model learns to summarize the trajectory in a single step.</p>

<div class="imgcap_noborder" style="display: block; margin-left: auto; margin-right: auto; width:100%; min-width: 300px">
  <img src="/assets/jumpy-rnn/lines.png" style="width:100%" />
</div>

<p>It‚Äôs worth noting that the way a system changes in time is only linear with respect to a particular coordinate system. For example, an object undergoing constant circular motion has nonlinear dynamics when we use Cartesian coordinates, but linear dynamics when we use Polar coordinates. That‚Äôs why physicists use different coordinates to describe different physical systems: the best coordinates are those that are maximally linear with respect to the dynamics.</p>

<p>Since a Jumpy RNN forces dynamics to be linear in latent space, the encoder and decoder layers naturally learn to transform input data into a basis where the dynamics are linear. For example, when we train our model on a dataset of circular trajectories represented in Cartesian coordinates, it learns to summarize such trajectories in a single step as well. This implies that circular motion is linear in the model‚Äôs latent space, and that it has effectively learned a Cartesian-to-Polar conversion.</p>

<div class="imgcap_noborder" style="display: block; margin-left: auto; margin-right: auto; width:100%; min-width: 300px">
  <img src="/assets/jumpy-rnn/circles.png" style="width:100%" />
</div>

<p>Our model can learn more complicated change-of-basis functions as well. Later in the paper, we trained our model on pixel observations of two billiards balls. The pixel ‚Äúcoordinate system‚Äù is extremely nonlinear with respect to the linear motion of the two balls. And yet our model was able to predict the dynamics of the system <em>more effectively</em> than the baseline model using three times fewer ‚Äúticks.‚Äù This jumpiness implies that our model found a basis in which the billiards dynamics were linear for significant durations of time ‚Äì something that would never happen in a pixel basis.</p>

<div class="imgcap_noborder" style="display: block; margin-left: auto; margin-right: auto; width:100%; min-width: 300px">
  <img src="/assets/jumpy-rnn/pixel_billiards.png" style="width:100%" />
</div>

<p>In fact, we suspect that forcing dynamics to be linear in latent space actually <em>biased</em> our model to find linear dynamics. We hypothesize that the baseline model performed worse on this task because it had no such inductive bias.</p>

<h2 id="planning">Planning</h2>

<p>One of the reasons we originally set out to build a Jumpy RNN was that we wanted to use it for planning. We were struck by the fact that many events one would want to plan over ‚Äì collisions, in the case of billiards ‚Äì are separated by variable durations of time. We suspected that a jumpy model would be particularly effective at planning in such scenarios.</p>

<p>In order to test this hypothesis, we tested our model against a baseline RNN on a simple planning task in the billiards environment. The goal was to impart one ball, the ‚Äúcue ball‚Äù (visualized in tan) with an initial velocity such that it would collide with the second ball and the second ball would ultimately enter a target region (visualized in black).</p>

<p>We found that our model used half the wall time of the baseline and produced plans with a higher probability of success. These results are preliminary ‚Äì and part of ongoing work ‚Äì but they do confirm our hypothesis that the jumpy model would be useful for model-based planning.</p>

<h2 id="related-work">Related Work</h2>

<p><strong>Other continuous-time models.</strong> One challenge in training neural ODEs is that they must be continuously solved even when no observations occur, making forward passes take 60\% - 120\% longer than standard RNNs \citep{rubanova2019latent}. Since the integration speed of a Neural ODE is proportional to the curvature of the hidden state dynamics (higher curvature requires more steps), one can improve speed and efficiency by regularizing that curvature. \cite{finlay2020train} take a step in this direction. Even so, the number of time steps per function evaluation tends to be less than one. Our model resembles Neural ODEs in that it parameterizes the derivative of a hidden state. However, we make the simplifying assumption that the hidden state dynamics are linear for long stretches of time. This makes our model extremely efficient to integrate over long spans of time ‚Äì more efficient, in fact, than a baseline RNN. This jumpy behavior is what our model is designed for, and where it excels compared to Neural ODEs.</p>

<p><strong>Other approaches to temporal abstraction.</strong> There are other RNN-based models designed with temporal abstraction in mind. \cite{koutnik2014clockwork} proposed dividing an RNN internal state into groups and only performing cell updates on the $i^{th}$ group after $2^{i-1}$ time steps. More recent works have aimed to make this hierarchical structure more adaptive, either by data-specific rules \citep{ling2015character} or by a learning  mechanism \citep{chung2019hierarchical}. All of these hierarchical recurrent models can model data at different timescales, but they all \textit{must} perform cell updates at every time step in a sequence, and hence cannot jump over regions of homogeneous change.</p>

<p>Recent work by \cite{gregor2018temporal} in the context of reinforcement learning develops a jumpy planning model which does not use an RNN cell or perform continuous interpolation of latent states. Another relevant work in the field of RL is Embed to Control by \cite{watter2015embed}. Their work is similar to ours in that they assume that dynamics are linear in latent space and they train their model on several dynamics problems, some of them with pixel observations. But unlike our work, their model performs inference over discrete, uniform time steps and does not learn a jumpy behavior.</p>

<h2 id="conclusions">Conclusions</h2>

<p>Having achieved widespread use in commercial and academic settings, RNNs are already a useful tool. But even though they are useful tools, they still have fundamental limitations. In this paper, we reckoned with the fact that they can only forecast the future in discrete, uniform time steps. In order to make RNNs more useful in more contexts, it is essential to find solutions to such restrictions. With this in mind, we proposed a Jumpy RNN model which can skip over long durations of comparatively homogeneous change and focus on pivotal events as the need arises. We hope that this line of work will expand the possible uses of RNNs and make them capable of representing time in a more efficient and flexible manner.</p>

<h2 id="footnotes">Footnotes</h2>

:ET